# NGINX Configuration Example for Keycloak and Microservices
#
# This is an example configuration. You will need to customize it for your environment.
# - Replace placeholders for server names, certificate paths, and upstream service addresses.
# - Adjust proxy settings and security configurations as needed.

# Main NGINX worker processes and error logging (usually in the main nginx.conf)
# user www-data; # Or your NGINX user
# worker_processes auto;
# pid /run/nginx.pid;
# include /etc/nginx/modules-enabled/*.conf;

# events {
#    worker_connections 768;
# }

http {
    # Basic Settings
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    # server_tokens off; # Hide NGINX version

    # Mime types
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # Logging Settings
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    # Gzip Settings (optional)
    # gzip on;
    # gzip_disable "msie6";
    # gzip_vary on;
    # gzip_proxied any;
    # gzip_comp_level 6;
    # gzip_buffers 16 8k;
    # gzip_http_version 1.1;
    # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

    # Define upstream servers for better management (optional, can also proxy_pass directly)
    # upstream keycloak_server {
    #     # Assuming Keycloak is running and accessible via this address from NGINX
    #     # If Keycloak is on the same Docker network, use its service name and container port.
    #     # For HTTPS between NGINX and Keycloak: server keycloak_service_name:8443;
    #     server keycloak:8080; # Example: keycloak is the service name in docker-compose
    # }
    #
    # upstream invoice_service_upstream {
    #     server invoice_app_host:8081; # Replace with actual host/port or service name
    # }
    #
    # upstream email_service_upstream {
    #     server email_app_host:8082; # Replace with actual host/port or service name
    # }
    #
    # upstream sales_dashboard_upstream {
    #     server sales_app_host:8083; # Replace with actual host/port or service name
    # }
    #
    # upstream protected_api_upstream {
    #    server protected_resource_host:8090; # Replace with actual host/port
    # }

    # Server block for HTTP to HTTPS redirection (optional, but recommended)
    server {
        listen 80;
        server_name your_domain.com www.your_domain.com; # Replace with your domain

        location / {
            return 301 https://$host$request_uri;
        }

        # For Let's Encrypt ACME challenge (if used)
        location /.well-known/acme-challenge/ {
            root /var/www/certbot; # Or your Certbot webroot path
        }
    }

    # Main server block for HTTPS
    server {
        listen 443 ssl http2; # Enable HTTP/2 for better performance
        server_name your_domain.com www.your_domain.com; # Replace with your domain

        # SSL/TLS Configuration
        # IMPORTANT: Replace with paths to your actual SSL certificate and private key
        ssl_certificate /etc/nginx/ssl/tls.crt;         # e.g., /etc/letsencrypt/live/your_domain.com/fullchain.pem
        ssl_certificate_key /etc/nginx/ssl/tls.key;     # e.g., /etc/letsencrypt/live/your_domain.com/privkey.pem

        # Strong SSL Security Settings (refer to Mozilla SSL Config Generator for up-to-date recommendations)
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;
        ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 1d; # Adjust as needed
        ssl_session_tickets off; # Consider security implications if enabling
        # ssl_stapling on; # Requires resolver and trusted certificate for OCSP
        # ssl_stapling_verify on;
        # resolver 8.8.8.8 8.8.4.4 valid=300s; # Example resolver for OCSP stapling

        # Add HSTS header (optional, but recommended for security)
        # add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;

        # Security Headers (optional, but recommended)
        # add_header X-Frame-Options DENY;
        # add_header X-Content-Type-Options nosniff;
        # add_header X-XSS-Protection "1; mode=block";
        # add_header Referrer-Policy "strict-origin-when-cross-origin";

        # --- Location Block for Keycloak ---
        # Keycloak typically runs under the /auth/ context path.
        # If your Keycloak is configured with a different context path, adjust accordingly.
        location /auth/ {
            # Proxy to Keycloak.
            # If Keycloak is running in Docker on the same network, use its service name.
            # Replace 'keycloak:8080' with your Keycloak instance address.
            # If NGINX to Keycloak communication should also be HTTPS, use https://keycloak_service_name:8443/auth/
            # Ensure Keycloak's KC_PROXY is set to 'edge' or 'passthrough'
            proxy_pass http://keycloak:8080/auth/; # Assumes keycloak service name and http port from docker-compose

            # Set headers to pass necessary information to Keycloak
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme; # $scheme will be 'https' due to SSL termination
            proxy_set_header X-Forwarded-Host $host;
            proxy_set_header X-Forwarded-Server $host;
            proxy_set_header X-Forwarded-Port $server_port;

            # Recommended for WebSockets if Keycloak uses them (e.g., for admin console events)
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";

            proxy_read_timeout 90s; # Adjust as needed
            proxy_connect_timeout 90s;
        }

        # --- Location Blocks for Microservices ---
        # These are examples. Adjust paths and upstream addresses for your microservices.

        location /invoice/ {
            # Example: Proxy to Invoice microservice
            # proxy_pass http://invoice_service_upstream/invoice/; # Using defined upstream
            proxy_pass http://invoice_service_host:8081/; # Replace with actual service address
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /email/ {
            # Example: Proxy to Email microservice
            proxy_pass http://email_service_host:8082/; # Replace with actual service address
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /sales/ {
            # Example: Proxy to Sales Dashboard microservice
            proxy_pass http://sales_dashboard_host:8083/; # Replace with actual service address
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # --- Location Block for a Protected API with JWT Validation Guidance ---
        location /api/protected_resource/ {
            # This block demonstrates how to protect an API endpoint using JWTs issued by Keycloak.

            # **Option 1: Using NGINX's `auth_request` directive (Recommended for NGINX Open Source)**
            # This method delegates token validation to an external service, such as Keycloak's
            # UserInfo or Introspection endpoint, or a small dedicated authentication service.

            # 1. Define an internal location for the authentication request.
            #    This request will be sent to Keycloak's introspection endpoint.
            #    The introspection endpoint requires client authentication (the client that is allowed to introspect tokens).
            #    This client should be confidential with "Service Accounts Enabled" in Keycloak.
            #    The Authorization header will contain "Basic <base64_encoded_clientid:clientsecret>".
            #
            # location = /_validate_token {
            #     internal; # Ensures this location can only be accessed by NGINX internally
            #     proxy_method POST;
            #     # Replace with your Keycloak realm's introspection endpoint URL
            #     proxy_pass http://keycloak:8080/auth/realms/microservices_realm/protocol/openid-connect/token/introspect;
            #
            #     # Set necessary headers for the introspection request
            #     proxy_set_header Content-Type "application/x-www-form-urlencoded";
            #     # The token is usually passed from the original request's Authorization header (Bearer token)
            #     # This requires NGINX variables or Lua/Perl scripting to extract and send.
            #     # A simpler way for auth_request is to check if the introspection endpoint returns 200 OK.
            #     # The actual token needs to be sent in the body: token=$http_authorization (after stripping 'Bearer ')
            #     # This part can be tricky with vanilla NGINX auth_request for introspect.
            #     # A common pattern is to have a small service that takes the token from header and does the introspect call.
            #
            #     # For UserInfo endpoint (simpler, but token must be an access token, not necessarily opaque):
            #     # proxy_pass http://keycloak:8080/auth/realms/microservices_realm/protocol/openid-connect/userinfo;
            #     # proxy_set_header Authorization $http_authorization; # Pass the original Bearer token
            #
            #     proxy_pass_request_body off; # Don't send original request body to auth endpoint
            #     proxy_set_header Content-Length "";
            #     proxy_set_header X-Original-URI $request_uri;
            # }
            #
            # auth_request /_validate_token;
            #
            # # If auth_request succeeds (2xx response), the request is proxied to the backend.
            # # If auth_request fails (401, 403), NGINX returns that status to the client.
            # # To customize the error response:
            # # error_page 401 = @error_401;
            # # location @error_401 { return 401 '{"error": "Unauthorized"}\n'; }

            # **Option 2: Native JWT Validation (NGINX Plus or Third-Party Modules)**
            # - NGINX Plus offers native JWT validation with the `auth_jwt` directive.
            #   See: https://docs.nginx.com/nginx/admin-guide/security-controls/authenticating-users-jwt/
            #   Example (NGINX Plus):
            #   auth_jwt "realm_name";
            #   auth_jwt_key_file /etc/nginx/jwk.json; # Path to JWK file for signature verification
            #
            # - For NGINX Open Source, third-party modules can provide similar functionality:
            #   - `lua-resty-openidc` (OpenID Connect and JWT validation using Lua): https://github.com/zmartzone/lua-resty-openidc
            #   - `ngx_http_auth_jwt_module` (Validates JWTs): https://github.com/TeslaGov/ngx-http-auth-jwt-module
            #   These modules require compiling NGINX with them or using a version that includes them.

            # **Placeholder for actual token validation logic**
            # For now, this example just proxies through. Implement one of the options above.
            # If no validation is configured here, the backend service is responsible for validating the JWT.
            # It's often better to validate at the gateway/edge.

            # Add a comment indicating that the below proxy_pass assumes authentication was successful
            # or is handled by the upstream service.
            # If using auth_request, NGINX handles unauthorized access before this point.

            proxy_pass http://protected_api_host:8090/; # Replace with actual service address
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            # Pass the original Authorization header (containing the JWT) to the backend service
            # if the backend service also needs to inspect or use the token.
            proxy_set_header Authorization $http_authorization;
        }

        # Optional: Basic health check endpoint (can be customized)
        location /nginx_health {
            access_log off;
            return 200 "OK";
            # More advanced health check: proxy_pass to an internal health check service
        }
    }
}
